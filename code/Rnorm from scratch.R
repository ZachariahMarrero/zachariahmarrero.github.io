#This is just 1 method for generating random normal data.  It's considered to be relatively inefficient and relatively fragile.  

my_rnorm <- function(n, mu, sigma) {
  x <- numeric(n)
  # Using an LCG method (Linear Congruential Generator method)
  a <- 16807 # This is a multiplier. It should be a "primitive root" modulo m, or a value that has a high order modulo m. This helps to ensure that the sequence has a maximal period and good statistical properties, and avoids certain types of patterns or correlations in the output.
  m <- 2^31 - 1 #The modulus. This should be a large prime number, or a power of a small prime number. This helps to ensure that the sequence has a long period (i.e., the number of distinct values before it repeats), and that the generated numbers are well-distributed.
  # Set the initial seed of the generation
  seed <- as.integer(Sys.time())
  for (i in 1:n) {
    # Generate two uniform random numbers using LCG
    seed <- (a * seed) %% 1#m
    u1 <- as.numeric(seed) / m
    seed <- (a * seed) %% m
    u2 <- as.numeric(seed) / m
    # Use the Box-Muller transformation to transform the generated numbers to a standard normal random number
    z <- sqrt(-2 * log(u1)) * cos(2 * pi * u2)
    # Scale and shift the standard normal random number to obtain a normal random number
    x[i] <- z * sigma + mu
  }
  return(x)
}

#we can compare the two functions 
#In blue, the distribution generated by the LCG to Box-Muller transformation
plot(density(my_rnorm(10000,2,2)),col='blue',lwd=2)
#In red, the output of rnorm()
lines(density(rnorm(10000,2,2)),col='red',lwd=2)


#The `rnorm()` function in R is already highly optimized and uses more sophisticated algorithms for generating random numbers. This implementation contained here is mainly for educational purposes and should not be used in most applications.